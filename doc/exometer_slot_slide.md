

# Module exometer_slot_slide #
* [Description](#description)
* [Function Index](#index)
* [Function Details](#functions)






### <a name="Introduction">Introduction</a> ###


This module defines a sliding time-window histogram with execution
cost control.
.

<a name="description"></a>

## Description ##

The problem with traditional histograms is that every sample is
stored and processed, no matter what the desired resolution is.



If a histogram has a sliding window of 100 seconds, and we have a
sample rate of 100Hz will give us 10000 elements to process every time
we want to calculate that average, which is expensive.
The same goes for min/max finds, percentile calculations, etc.



The solution is to introduce cost-control, where we can balance
execution time against sample resolution.



The obvious implementation is to lower the sample rate by throwing
away samples and just store evey N samples. However, this will
mean potentially missed min/max values, and other extreme data
that is seen by the edge code but is thrown away.



A slotted slide histogram will defined a number of time slots, each
spanning a fixed number of milliseconds. The slider then stores
slots that cover a given timespan into the past (a rolling
historgram). All slots older than the timespan are discarded.



The "current" slot is defined as the time period between the time
stamp of the last stored slot and the time when it is time to store
the next slot. If the slot period (size) is 100ms, and the last
slot was stored in the histogram at msec 1200, the current slot
period ends at msec 1300.



All samples received during the current slot are processed by an
low-cost MFA that updates the current slot state. When the current
slot ends, another MFA is used to transform the current slot state
to a value that is stored in the histogram.



If a simple average is to be calculated for all samples received,
the sample-processing MFA will add to the sum of the received
samples, and increment sample counter. When the current slot
expires, the result of SampleSum / SampleCount is stored in the
slot.



If min/max are to be stored by the slotted histograms, the current
slot state would have a { Min, Max } tuple that is upadted with the
smallest and largest values received during the period. At slot
expiration the min/max tuple is simply stored, by the
transformation MFA, in the histogram slots.



By adjusting the slot period and the total histogram duration, the
cost of analysing the entire histogram can be balanced against
the resolution of that analysis.


### <a name="SLOT_HISTOGRAM_MANAGEMENT">SLOT HISTOGRAM MANAGEMENT</a> ###



The slide state has maintains a list of { TimeStamp, SlotElem }
slot tuples. TimeStamp is the time period (in monotonic ms),
rounded down to the resolution of the slot period, and SlotElem is
the tuple generated by the current slot transformation MFA. The
list is sorted on descending time stamps (newest slot first).



Normally each element in the list has a timestamp that is
SlotPeriod milliseconds newer than the next slot in the
list. However, if no samples are received during the current slot,
no slot for that time stamp will be stored, leaving a hole in the
list.  Normally, the the slot list would look like this (with a 100
msec slot period and a simple average value):



```erlang

      [ { 1400, 23.2 }, { 1300, 23.1 }, { 1200, 22.8 }, { 1100, 23.0 } ]
$ 
```



If no samples were received during the period between 1200 and 1300
(ms), no slot would be stored at that time stamp, yielding the
following list:



```erlang

      [ { 1400, 23.2 }, { 1300, 23.1 }, { 1100, 23.0 } ]
$ 
```



This means that the total length of the slot list may vary, even
if it always covers the same time span into the past.




### <a name="SLOT_LISTS">SLOT LISTS</a> ###

<a name="index"></a>

## Function Index ##


<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#add_element-2">add_element/2</a></td><td></td></tr><tr><td valign="top"><a href="#add_element-3">add_element/3</a></td><td></td></tr><tr><td valign="top"><a href="#foldl-3">foldl/3</a></td><td></td></tr><tr><td valign="top"><a href="#foldl-4">foldl/4</a></td><td></td></tr><tr><td valign="top"><a href="#foldr-3">foldr/3</a></td><td></td></tr><tr><td valign="top"><a href="#foldr-4">foldr/4</a></td><td></td></tr><tr><td valign="top"><a href="#new-2">new/2</a></td><td></td></tr><tr><td valign="top"><a href="#new-4">new/4</a></td><td></td></tr><tr><td valign="top"><a href="#reset-1">reset/1</a></td><td></td></tr><tr><td valign="top"><a href="#test-0">test/0</a></td><td></td></tr><tr><td valign="top"><a href="#to_list-1">to_list/1</a></td><td></td></tr></table>


<a name="functions"></a>

## Function Details ##

<a name="add_element-2"></a>

### add_element/2 ###


<pre><code>
add_element(Val::any(), Slide::#slide{}) -&gt; #slide{}
</code></pre>

<br></br>



<a name="add_element-3"></a>

### add_element/3 ###

`add_element(TS, Val, Slide) -> any()`


<a name="foldl-3"></a>

### foldl/3 ###

`foldl(Fun, Acc, Slide) -> any()`


<a name="foldl-4"></a>

### foldl/4 ###

`foldl(TS, Fun, Acc, Slide) -> any()`


<a name="foldr-3"></a>

### foldr/3 ###

`foldr(Fun, Acc, Slide) -> any()`


<a name="foldr-4"></a>

### foldr/4 ###

`foldr(TS, Fun, Acc, Slide) -> any()`


<a name="new-2"></a>

### new/2 ###

`new(HistogramTimeSpan, SlotPeriod) -> any()`


<a name="new-4"></a>

### new/4 ###


<pre><code>
new(HistogramTimeSpan::integer(), SlotPeriod::integer(), SampleMFA::{atom(), atom(), list()}, TransformMFA::{atom(), atom(), list()}) -&gt; #slide{}
</code></pre>

<br></br>



<a name="reset-1"></a>

### reset/1 ###


<pre><code>
reset(Slide::#slide{}) -&gt; #slide{}
</code></pre>

<br></br>



<a name="test-0"></a>

### test/0 ###

`test() -> any()`


<a name="to_list-1"></a>

### to_list/1 ###


<pre><code>
to_list(Slide::#slide{}) -&gt; list()
</code></pre>

<br></br>



